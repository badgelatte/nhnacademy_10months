== Mainflux

=== Wait is Mainflux?

Mainflux는 현대적이고 확장 가능하며 안전한 오픈 소스 및 특허가 없는 IoT 클라우드 플랫폼으로, Go 언어로 작성되었습니다.

이 플랫폼은 사용자와 장치가 다양한 네트워크 프로토콜(HTTP, MQTT, WebSocket, CoAP 등)을 통해 연결되도록 지원하며, 이들 간의 원활한 연결을 제공합니다. Mainflux는 복잡한 IoT 솔루션을 구축하기 위한 IoT 미들웨어로 사용됩니다.

image::https://mainfluxlabs.github.io/docs/img/gopherBanner.jpg[]

주요 기능:
- 프로토콜 간 연결 (예: HTTP, MQTT, WebSocket, CoAP)
- 장치 관리 및 프로비저닝
- 세분화된 접근 제어
- 플랫폼 로깅 및 계측 지원
- Docker를 사용한 컨테이너 기반 배포

=== Architecture

Mainflux IoT 플랫폼은 다음 서비스로 구성됩니다:

[cols="1,4",frame=none,grid=none]
|===
|서비스
|설명

s|users
|플랫폼 사용자와 인증 관련 사항 관리

s|things
|플랫폼의 장치, 채널 및 접근 정책 관리

s|http-adapter
|커뮤니케이션 채널 접근을 위한 HTTP 인터페이스 제공

s|mqtt-adapter
|MQTT 및 MQTT over WS 인터페이스를 통한 커뮤니케이션 채널 접근 제공

s|coap-adapter
|커뮤니케이션 채널 접근을 위한 CoAP 인터페이스 제공

s|opcua-adapter
|커뮤니케이션 채널 접근을 위한 OPC-UA 인터페이스 제공

s|lora-adapter
|커뮤니케이션 채널 접근을 위한 LoRa 서버 포워더 제공

s|mainflux-cli
|커맨드 라인 인터페이스
|===

image::https://mainfluxlabs.github.io/docs/img/architecture.jpg[]

==== Domain Model

이 플랫폼은 주로 3가지 주요 엔티티로 구성됩니다: *user*, *thing*, *channel*.

* **user**: 시스템의 실제 (인간) 사용자를 나타냅니다. 이메일과 비밀번호를 통해 플랫폼 접근 자격 증명으로 사용하며, 이를 통해 접근 토큰을 획득합니다. 시스템에 로그인하면 사용자는 자신의 리소스(장치 및 채널)를 CRUD 방식으로 관리하고 연결하여 접근 제어 정책을 정의할 수 있습니다.

* **Thing**: Mainflux에 연결된 장치(또는 애플리케이션)를 나타냅니다. 이는 다른 "장치"와 메시지 교환을 위해 플랫폼을 사용합니다.

* **Channel**: 커뮤니케이션 채널을 나타냅니다. 이는 연결된 모든 장치가 사용할 수 있는 메시지 주제로 사용됩니다.

==== Messaging(메시징)

Mainflux는 가벼우면서도 성능이 뛰어난 NATS를 메시징 백본으로 사용합니다. NATS의 주제는 Mainflux 채널의 물리적 표현으로 간주할 수 있으며, 주제 이름은 채널 고유 식별자를 사용하여 구성됩니다.

일반적으로 채널을 통해 교환되는 내용에 제한은 없습니다. 그러나 후처리 및 정규화를 위해서는 SenML을 사용하여 메시지를 포맷팅하는 것이 좋습니다.

==== Edge(엣지)

Mainflux 플랫폼은 엣지에서도 실행될 수 있습니다. 게이트웨이에 Mainflux를 배포하면 데이터 수집, 저장, 분석, 장치 조직화 및 인증이 가능해집니다. 게이트웨이에서 실행되는 Mainflux 인스턴스를 클라우드의 Mainflux와 연결하기 위해 두 가지 게이트웨이 서비스가 개발되었습니다:

Agent
Export

==== Unified IoT Platform(통합 IoT 플랫폼)

게이트웨이에서 Mainflux를 실행하면 계산이 클라우드에서 엣지로 이동하므로 IoT 시스템이 분산됩니다. 게이트웨이와 클라우드에 동일한 Mainflux 코드를 배포할 수 있기 때문

에 여러 이점이 있지만, 가장 큰 이점은 배포 및 채택이 쉽다는 것입니다 - 엔지니어들이 플랫폼의 배포 및 유지 관리 방법을 이해하면, 그들은 전체 엣지-포그-클라우드 연속체에서 동일한 알려진 작업을 가지게 됩니다. 동일한 도구 세트를 사용할 수 있으며, 동일한 패치와 버그 수정이 적용될 수 있습니다. 전체 시스템에 대해 생각하기가 훨씬 쉬워지고, 유지 관리가 훨씬 쉽고 비용이 적게 듭니다.
