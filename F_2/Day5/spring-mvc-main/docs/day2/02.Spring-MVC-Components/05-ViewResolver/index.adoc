= ViewResolver

== 문자열 기반의 view 이름을 토대로 실제 View 구현을 결정하는 역할

* InternalResourceViewResolverd
** default
** jsp 지원
* VelocityViewResolver
* FreemarkerViewResolver
* ThymeleafViewResolver
* …

== ViewResolver 관련 Components

=== LocaleResolver / LocaleContextResolver
* view rendering 시 국제화 지원을 위한 Locale과 Timezone을 결정하는 역할

|===
|class |설명 

|AcceptHeaderLocaleResolver
|웹 브라우저가 전송한 Accept-Language 헤더로부터 Locale 선택한다. setLocale() 메서드를지원 하지 않는다.

|CookieLocaleResolver
|쿠키를 이용해서 Locale 정보를 구한다. setLocale() 메서드는 쿠키에 Locale 정보를 저장한다

|SessionLocaleResolver
|세션으로부터 Locale 정보를 구한다. setLocale() 메서드는 세션에 Locale 정보를 저장한다.
|FixedLocaleResolver
|웹 요청에 상관없이 특정한 Locale로 설정한다. setLocale() 메서드를 지원하지 않는다.
|===

=== ThemeResolver

* view rendering 시 어떤 테마를 사용할 지 결정하는 역할

|===
|class|설명

|CookieThemeResolver
|테마를 사용자별로 설정할 수 있도록 해주며 사용되는 테마 정보가 클라이언트의 쿠키에 저장된다.

|SessionThemeResolver
|테마를 사용자의 세션별로 설정할 수 있도록 한다.

|FixedThemeResolver
|빈의 defaultThemeName 속성에 설정된 하나의 고정된 테마를 반환한다.

|===

=== RequestToViewNameTranslator

* 핸들러가 아무것도 리턴하지 않았을 때 view 이름을 결정하는 역할

== HandlerExceptionResolver

=== 요청 처리 과정에서 발생하는 예외를 제어하고자 할 때 사용

* `DefaultHandlerExceptionResolver`
** 표준 Spring 예외를 결정하고 예외에 해당하는 HTTP 상태 코드를 응답

----
DefaultHandlerExceptionResolver는 스프링 MVC에서 제공하는 예외 처리를 담당하는 클래스로, 예외가 발생했을 때 기본적인 예외 처리 로직을 수행합니다. 

 - 예외에 따른 HTTP 응답 처리: 예외가 발생했을 때, HTTP 응답의 상태 코드와 메시지를 적절하게 설정하여 클라이언트에게 전달합니다. 
   예를 들어, 예외가 발생하면 500 (Internal Server Error) 상태 코드를 반환하고, 예외 메시지를 응답 본문에 포함시켜 클라이언트에게 전달할 수 있습니다.

 - 예외 처리 메시지 변환: 예외 메시지를 클라이언트에게 전달하기 전에, 메시지를 변환하거나 포맷팅할 수 있습니다. 
   예를 들어, 예외 메시지를 JSON 형식으로 변환하여 클라이언트에게 반환할 수 있습니다.

 - 예외 처리 로깅: 예외가 발생했을 때, 로깅을 통해 예외 정보를 기록할 수 있습니다. 이를 통해 개발자가 예외를 추적하고 디버깅할 수 있습니다.

DefaultHandlerExceptionResolver는 스프링 MVC의 예외 처리 과정에서 자동으로 적용되는 예외 처리기로 제공되기 때문에 별도의 설정이 필요하지 않습니다. 
예외가 발생하면 DefaultHandlerExceptionResolver가 자동으로 동작하여 예외를 처리하고, HTTP 응답을 적절하게 설정합니다. 
또한, 개발자가 커스텀 예외 처리 로직을 구현하여 사용할 수도 있습니다. 
이를 위해 커스텀 ExceptionResolver를 등록하여 DefaultHandlerExceptionResolver의 동작을 오버라이딩할 수 있습니다.

----

== 기타

=== MultipartResolver

* Multipart 요청을 처리하는 구현을 결정하는 역할

* CommonsMultipartResolver
* *StandardServletMultipartResolver*
** *Servlet 3.0 API 기반*

=== FlashMapManager

* redirect와 같이 하나의 요청에서 다른 요청으로 속성 값을 전달하는데 FlashMap을 사용할 수 있는 mechanism을 제공

=== RedirectAttribute vs FlashMapManager

* login fail시 출력했던 message -&gt; RedirectAttribute 활용해서 구현.

----
RedirectAttribute와 FlashMapManager는 둘 다 Spring에서 리다이렉트 후에 데이터를 전달하기 위한 기능을 제공하는데, 
그러나 둘 간에 몇 가지 차이점이 있습니다.

 - 데이터의 보관 위치: RedirectAttribute는 리다이렉트된 요청의 URL에 쿼리 매개변수로 데이터를 전달합니다. 즉, URL에 데이터가 노출되어 보안상 취약할 수 있습니다. 반면에, FlashMapManager는 서버 측에서 임시 데이터를 보관하므로 URL에 데이터가 노출되지 않습니다.

- 데이터의 보존 기간: RedirectAttribute는 리다이렉트된 요청에서만 데이터를 보존하며, 다음 요청에서는 사용할 수 없습니다. 반면에, FlashMapManager는 다음 요청에서도 데이터를 유지할 수 있습니다. 이는 FlashMapManager가 서버 측에서 데이터를 보존하기 때문입니다.

 - 데이터의 활용 범위: RedirectAttribute는 리다이렉트된 요청 내에서만 데이터를 사용할 수 있습니다. 반면에, FlashMapManager는 다음 요청에서도 데이터를 사용할 수 있습니다. 이는 FlashMapManager가 서버 측에서 데이터를 보관하므로 다양한 요청에서 데이터를 활용할 수 있는 장점이 있습니다.

 - 데이터의 삭제 처리: RedirectAttribute는 리다이렉트된 요청에서 데이터를 사용하면 자동으로 삭제되며, 다음 요청에서는 사용할 수 없습니다. 반면에, FlashMapManager는 데이터의 삭제 처리를 개발자가 직접 관리해야 합니다. 개발자가 데이터를 수동으로 삭제하지 않으면 FlashMapManager에 계속 남아있을 수 있습니다.

종합적으로 말하면, RedirectAttribute는 리다이렉트된 요청에서만 사용 가능하고 URL에 데이터가 노출되는 단점이 있지만, 간단하게 사용할 수 있는 반면에, FlashMapManager는 서버 측에서 데이터를 보존하고 다양한 요청에서 활용할 수 있는 장점이 있지만, 개발자가 데이터의 삭제 처리를 관리해야 하는 등 좀 더 복잡한 사용 방법이 필요할 수 있습니다. 따라서 상황에 맞게 RedirectAttribute 또는 FlashMapManager를 선택하여 사용해야 합니다.
----